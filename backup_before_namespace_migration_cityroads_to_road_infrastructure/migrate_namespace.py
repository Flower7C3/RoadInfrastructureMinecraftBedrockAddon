#!/usr/bin/env python3
"""
Skrypt do migracji namespace z 'jct' na 'cityroads'
Automatycznie aktualizuje wszystkie pliki projektu i tworzy skrypt do aktualizacji blok√≥w na ≈õwiecie
"""

import os
import json
import glob
import shutil
from pathlib import Path

# Konfiguracja migracji
OLD_NAMESPACE = "cityroads"
NEW_NAMESPACE = "road_infrastructure"

def backup_project():
    """Tworzy kopiƒô zapasowƒÖ projektu przed migracjƒÖ"""
    backup_dir = f"backup_before_namespace_migration_{OLD_NAMESPACE}_to_{NEW_NAMESPACE}"
    if os.path.exists(backup_dir):
        shutil.rmtree(backup_dir)
    
    print(f"üì¶ Tworzenie kopii zapasowej: {backup_dir}")
    shutil.copytree(".", backup_dir, ignore=shutil.ignore_patterns(
        "backup_*", "dist", "venv", "__pycache__", "*.pyc", ".git"
    ))
    print(f"‚úÖ Kopia zapasowa utworzona: {backup_dir}")
    return backup_dir

def update_config_json():
    """Aktualizuje config.json"""
    print("üîß Aktualizacja config.json...")
    
    with open("config.json", "r", encoding="utf-8") as f:
        config = json.load(f)
    
    config["namespace"] = NEW_NAMESPACE
    
    with open("config.json", "w", encoding="utf-8") as f:
        json.dump(config, f, indent="\t", ensure_ascii=False)
    
    print("‚úÖ config.json zaktualizowany")

def update_block_files():
    """Aktualizuje wszystkie pliki .block.json"""
    print("üîß Aktualizacja plik√≥w .block.json...")
    
    block_files = glob.glob("BP/blocks/**/*.block.json", recursive=True)
    updated_count = 0
    
    for block_file in block_files:
        with open(block_file, "r", encoding="utf-8") as f:
            content = f.read()
        
        if f"{OLD_NAMESPACE}:" in content:
            content = content.replace(f"{OLD_NAMESPACE}:", f"{NEW_NAMESPACE}:")
            
            with open(block_file, "w", encoding="utf-8") as f:
                f.write(content)
            
            updated_count += 1
            print(f"  ‚úÖ {block_file}")
    
    print(f"‚úÖ Zaktualizowano {updated_count} plik√≥w .block.json")

def update_crafting_catalog():
    """Aktualizuje crafting_item_catalog.json"""
    print("üîß Aktualizacja crafting_item_catalog.json...")
    
    catalog_file = "BP/item_catalog/crafting_item_catalog.json"
    with open(catalog_file, "r", encoding="utf-8") as f:
        catalog = json.load(f)
    
    def update_items_recursive(obj):
        if isinstance(obj, dict):
            for key, value in obj.items():
                if isinstance(value, str) and value.startswith(f"{OLD_NAMESPACE}:"):
                    obj[key] = value.replace(f"{OLD_NAMESPACE}:", f"{NEW_NAMESPACE}:")
                elif isinstance(value, (dict, list)):
                    update_items_recursive(value)
        elif isinstance(obj, list):
            for item in obj:
                if isinstance(item, str) and item.startswith(f"{OLD_NAMESPACE}:"):
                    obj[obj.index(item)] = item.replace(f"{OLD_NAMESPACE}:", f"{NEW_NAMESPACE}:")
                elif isinstance(item, (dict, list)):
                    update_items_recursive(item)
    
    update_items_recursive(catalog)
    
    with open(catalog_file, "w", encoding="utf-8") as f:
        json.dump(catalog, f, indent=2, ensure_ascii=False)
    
    print("‚úÖ crafting_item_catalog.json zaktualizowany")

def update_localization_files():
    """Aktualizuje pliki lokalizacji"""
    print("üîß Aktualizacja plik√≥w lokalizacji...")
    
    lang_files = ["RP/texts/en_US.lang", "RP/texts/pl_PL.lang"]
    
    for lang_file in lang_files:
        if os.path.exists(lang_file):
            with open(lang_file, "r", encoding="utf-8") as f:
                content = f.read()
            
            # Zamie≈Ñ wszystkie wystƒÖpienia jct: na cityroads:
            content = content.replace(f"{OLD_NAMESPACE}:", f"{NEW_NAMESPACE}:")
            
            with open(lang_file, "w", encoding="utf-8") as f:
                f.write(content)
            
            print(f"  ‚úÖ {lang_file}")

def update_blocks_json():
    """Aktualizuje blocks.json"""
    print("üîß Aktualizacja blocks.json...")
    
    blocks_file = "RP/blocks.json"
    with open(blocks_file, "r", encoding="utf-8") as f:
        blocks = json.load(f)
    
    # Zamie≈Ñ klucze blok√≥w
    new_blocks = {}
    for key, value in blocks.items():
        if key.startswith(f"{OLD_NAMESPACE}:"):
            new_key = key.replace(f"{OLD_NAMESPACE}:", f"{NEW_NAMESPACE}:")
            new_blocks[new_key] = value
        else:
            new_blocks[key] = value
    
    with open(blocks_file, "w", encoding="utf-8") as f:
        json.dump(new_blocks, f, indent=2, ensure_ascii=False)
    
    print("‚úÖ blocks.json zaktualizowany")

def create_world_migration_script():
    """Tworzy skrypt do migracji blok√≥w na ≈õwiecie"""
    print("üîß Tworzenie skryptu migracji ≈õwiata...")
    
    script_content = f'''#!/usr/bin/env python3
"""
Skrypt do migracji blok√≥w na ≈õwiecie z namespace '{OLD_NAMESPACE}' na '{NEW_NAMESPACE}'
Uruchom ten skrypt w ≈õwiecie Minecraft, aby zaktualizowaƒá wszystkie bloki
"""

import os
import json
import glob
from pathlib import Path

# Konfiguracja migracji
OLD_NAMESPACE = "{OLD_NAMESPACE}"
NEW_NAMESPACE = "{NEW_NAMESPACE}"

def find_minecraft_worlds():
    """Znajduje ≈õwiaty Minecraft"""
    home = str(Path.home())
    worlds = []
    
    # macOS
    mac_path = os.path.join(home, "Library/Application Support/minecraftpe")
    if os.path.exists(mac_path):
        worlds.extend(glob.glob(os.path.join(mac_path, "minecraftWorlds/*")))
    
    # Windows
    win_path = os.path.join(home, "AppData/Local/Packages/Microsoft.MinecraftUWP_8wekyb3d8bbwe/LocalState/games/com.mojang")
    if os.path.exists(win_path):
        worlds.extend(glob.glob(os.path.join(win_path, "minecraftWorlds/*")))
    
    return worlds

def migrate_world_level_dat(world_path):
    """Migruje plik level.dat w ≈õwiecie"""
    level_dat_path = os.path.join(world_path, "level.dat")
    if not os.path.exists(level_dat_path):
        return False
    
    print(f"üîß Migracja: {{os.path.basename(world_path)}}")
    
    # Tworzenie kopii zapasowej
    backup_path = level_dat_path + ".backup"
    shutil.copy2(level_dat_path, backup_path)
    
    try:
        # Odczyt pliku level.dat (to jest plik NBT, ale mo≈ºemy spr√≥bowaƒá prostego replace)
        with open(level_dat_path, "rb") as f:
            content = f.read()
        
        # Zamie≈Ñ namespace w danych
        old_bytes = OLD_NAMESPACE.encode('utf-8')
        new_bytes = NEW_NAMESPACE.encode('utf-8')
        
        if old_bytes in content:
            content = content.replace(old_bytes, new_bytes)
            
            with open(level_dat_path, "wb") as f:
                f.write(content)
            
            print(f"  ‚úÖ level.dat zaktualizowany")
            return True
        else:
            print(f"  ‚ö†Ô∏è  Nie znaleziono namespace {OLD_NAMESPACE} w level.dat")
            return False
            
    except Exception as e:
        print(f"  ‚ùå B≈ÇƒÖd migracji level.dat: {{e}}")
        # Przywr√≥ƒá kopiƒô zapasowƒÖ
        shutil.copy2(backup_path, level_dat_path)
        return False

def migrate_chunk_files(world_path):
    """Migruje pliki chunk w ≈õwiecie"""
    chunks_dir = os.path.join(world_path, "db")
    if not os.path.exists(chunks_dir):
        return False
    
    print(f"üîß Migracja chunk√≥w w: {{os.path.basename(world_path)}}")
    
    # Tworzenie kopii zapasowej
    backup_dir = chunks_dir + ".backup"
    if not os.path.exists(backup_dir):
        shutil.copytree(chunks_dir, backup_dir)
    
    try:
        # Znajd≈∫ wszystkie pliki chunk
        chunk_files = glob.glob(os.path.join(chunks_dir, "*.ldb"))
        
        updated_count = 0
        for chunk_file in chunk_files:
            try:
                with open(chunk_file, "rb") as f:
                    content = f.read()
                
                # Zamie≈Ñ namespace w danych
                old_bytes = OLD_NAMESPACE.encode('utf-8')
                new_bytes = NEW_NAMESPACE.encode('utf-8')
                
                if old_bytes in content:
                    content = content.replace(old_bytes, new_bytes)
                    
                    with open(chunk_file, "wb") as f:
                        f.write(content)
                    
                    updated_count += 1
            except Exception as e:
                print(f"  ‚ö†Ô∏è  B≈ÇƒÖd migracji {{chunk_file}}: {{e}}")
        
        print(f"  ‚úÖ Zaktualizowano {{updated_count}} plik√≥w chunk")
        return True
        
    except Exception as e:
        print(f"  ‚ùå B≈ÇƒÖd migracji chunk√≥w: {{e}}")
        return False

def main():
    """G≈Ç√≥wna funkcja migracji"""
    print("üåç MIGRACJA NAMESPACE W ≈öWIATACH MINECRAFT")
    print("=" * 60)
    print(f"Zmiana z: {{OLD_NAMESPACE}} ‚Üí {{NEW_NAMESPACE}}")
    print()
    
    # Znajd≈∫ ≈õwiaty
    worlds = find_minecraft_worlds()
    if not worlds:
        print("‚ùå Nie znaleziono ≈õwiat√≥w Minecraft")
        return
    
    print(f"üìÅ Znaleziono {{len(worlds)}} ≈õwiat√≥w:")
    for world in worlds:
        print(f"  - {{os.path.basename(world)}}")
    
    print()
    print("‚ö†Ô∏è  UWAGA: Przed migracjƒÖ zamknij Minecraft!")
    print("‚ö†Ô∏è  Ta operacja mo≈ºe uszkodziƒá ≈õwiaty - upewnij siƒô, ≈ºe masz kopiƒô zapasowƒÖ!")
    print()
    
    response = input("Czy chcesz kontynuowaƒá? (tak/nie): ").lower().strip()
    if response not in ["tak", "yes", "y"]:
        print("‚ùå Migracja anulowana")
        return
    
    print()
    
    # Migruj ka≈ºdy ≈õwiat
    success_count = 0
    for world in worlds:
        world_name = os.path.basename(world)
        print(f"üåç Migracja ≈õwiata: {{world_name}}")
        
        # Migruj level.dat
        level_success = migrate_world_level_dat(world)
        
        # Migruj chunki
        chunks_success = migrate_chunk_files(world)
        
        if level_success or chunks_success:
            success_count += 1
            print(f"‚úÖ ≈öwiat {{world_name}} zaktualizowany")
        else:
            print(f"‚ùå B≈ÇƒÖd migracji ≈õwiata {{world_name}}")
        
        print()
    
    print("=" * 60)
    print(f"üìä PODSUMOWANIE:")
    print(f"   üåç ≈öwiaty znalezione: {{len(worlds)}}")
    print(f"   ‚úÖ ≈öwiaty zaktualizowane: {{success_count}}")
    print(f"   ‚ùå B≈Çƒôdy: {{len(worlds) - success_count}}")
    
    if success_count > 0:
        print()
        print("üéâ Migracja zako≈Ñczona!")
        print("Uruchom Minecraft i sprawd≈∫ czy bloki dzia≈ÇajƒÖ poprawnie")
    else:
        print()
        print("‚ùå Migracja nie powiod≈Ça siƒô")

if __name__ == "__main__":
    main()
'''
    
    script_path = f"migrate_world_{OLD_NAMESPACE}_to_{NEW_NAMESPACE}.py"
    with open(script_path, "w", encoding="utf-8") as f:
        f.write(script_content)
    
    # Nadaj uprawnienia wykonywania
    os.chmod(script_path, 0o755)
    
    print(f"‚úÖ Skrypt migracji utworzony: {script_path}")

def create_migration_guide():
    """Tworzy przewodnik po migracji"""
    print("üìù Tworzenie przewodnika migracji...")
    
    guide_content = f'''# üîÑ Przewodnik Migracji Namespace

## üìã Opis

Ten przewodnik opisuje proces migracji namespace z `{OLD_NAMESPACE}` na `{NEW_NAMESPACE}` w projekcie City Roads.

## üöÄ Krok 1: Migracja Projektu

Projekt zosta≈Ç ju≈º zaktualizowany przez skrypt `migrate_namespace.py`.

### Zmienione Pliki:
- ‚úÖ `config.json` - namespace zaktualizowany
- ‚úÖ Wszystkie pliki `.block.json` - identyfikatory zaktualizowane
- ‚úÖ `crafting_item_catalog.json` - referencje zaktualizowane
- ‚úÖ Pliki lokalizacji (`.lang`) - nazwy zaktualizowane
- ‚úÖ `blocks.json` - klucze zaktualizowane

## üåç Krok 2: Migracja ≈öwiata

### Opcje Migracji:

#### Opcja A: Automatyczna Migracja (Zalecana)
```bash
python3 migrate_world_{OLD_NAMESPACE}_to_{NEW_NAMESPACE}.py
```

#### Opcja B: Rƒôczna Migracja
1. **Zamknij Minecraft**
2. **Utw√≥rz kopiƒô zapasowƒÖ ≈õwiata**
3. **Zaktualizuj pliki ≈õwiata** (level.dat, chunki)
4. **Uruchom Minecraft i przetestuj**

## ‚ö†Ô∏è Wa≈ºne Uwagi

### Przed MigracjƒÖ:
- ‚úÖ Zamknij Minecraft
- ‚úÖ Utw√≥rz kopiƒô zapasowƒÖ ≈õwiata
- ‚úÖ Sprawd≈∫ czy masz kopiƒô zapasowƒÖ projektu

### Po Migracji:
- ‚úÖ Uruchom Minecraft
- ‚úÖ Sprawd≈∫ czy bloki dzia≈ÇajƒÖ poprawnie
- ‚úÖ Przetestuj wszystkie funkcjonalno≈õci

## üîß RozwiƒÖzywanie Problem√≥w

### Problem: Bloki nie wy≈õwietlajƒÖ siƒô
**RozwiƒÖzanie:** Sprawd≈∫ czy:
- Namespace zosta≈Ç poprawnie zmieniony we wszystkich plikach
- ≈öwiat zosta≈Ç zaktualizowany
- Minecraft zosta≈Ç uruchomiony ponownie

### Problem: B≈Çƒôdy w grze
**RozwiƒÖzanie:** 
- Przywr√≥ƒá kopiƒô zapasowƒÖ ≈õwiata
- Sprawd≈∫ logi Minecraft
- Upewnij siƒô, ≈ºe wszystkie pliki sƒÖ sp√≥jne

## üìä Status Migracji

- ‚úÖ Projekt: Zaktualizowany
- ‚è≥ ≈öwiat: Wymaga migracji
- ‚è≥ Testowanie: Wymagane

## üéØ Nastƒôpne Kroki

1. **Uruchom skrypt migracji ≈õwiata**
2. **Przetestuj w Minecraft**
3. **Zaktualizuj dokumentacjƒô**
4. **Wypchnij zmiany na Git**

---
*Wygenerowano automatycznie przez skrypt migracji*
'''
    
    guide_path = "MIGRATION_GUIDE.md"
    with open(guide_path, "w", encoding="utf-8") as f:
        f.write(guide_content)
    
    print(f"‚úÖ Przewodnik utworzony: {guide_path}")

def main():
    """G≈Ç√≥wna funkcja migracji"""
    print("üîÑ MIGRACJA NAMESPACE")
    print("=" * 60)
    print(f"Zmiana z: {OLD_NAMESPACE} ‚Üí {NEW_NAMESPACE}")
    print()
    
    # Potwierdzenie u≈ºytkownika
    print("‚ö†Ô∏è  UWAGA: Ta operacja zmieni wszystkie identyfikatory blok√≥w!")
    print("‚ö†Ô∏è  Upewnij siƒô, ≈ºe masz kopiƒô zapasowƒÖ projektu!")
    print()
    
    response = input("Czy chcesz kontynuowaƒá? (tak/nie): ").lower().strip()
    if response not in ["tak", "yes", "y"]:
        print("‚ùå Migracja anulowana")
        return
    
    print()
    
    # Tworzenie kopii zapasowej
    backup_dir = backup_project()
    
    try:
        # Aktualizacja plik√≥w projektu
        update_config_json()
        update_block_files()
        update_crafting_catalog()
        update_localization_files()
        update_blocks_json()
        
        # Tworzenie skrypt√≥w pomocniczych
        create_world_migration_script()
        create_migration_guide()
        
        print()
        print("=" * 60)
        print("‚úÖ MIGRACJA PROJEKTU ZAKO≈ÉCZONA POMY≈öLNIE!")
        print()
        print("üìã Nastƒôpne kroki:")
        print("1. Przetestuj budowanie: python3 build.py --mcaddon --no-bump")
        print("2. Uruchom migracjƒô ≈õwiata: python3 migrate_world_jct_to_cityroads.py")
        print("3. Przetestuj w Minecraft")
        print("4. Wypchnij zmiany na Git")
        print()
        print(f"üì¶ Kopia zapasowa: {backup_dir}")
        print("üìù Przewodnik: MIGRATION_GUIDE.md")
        
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd podczas migracji: {e}")
        print(f"üì¶ Przywracanie z kopii zapasowej: {backup_dir}")
        
        # Przywr√≥ƒá z kopii zapasowej
        if os.path.exists(backup_dir):
            for item in os.listdir("."):
                if item not in [backup_dir, ".git"]:
                    if os.path.isdir(item):
                        shutil.rmtree(item)
                    else:
                        os.remove(item)
            
            for item in os.listdir(backup_dir):
                src = os.path.join(backup_dir, item)
                dst = os.path.join(".", item)
                if os.path.isdir(src):
                    shutil.copytree(src, dst)
                else:
                    shutil.copy2(src, dst)
            
            print("‚úÖ Projekt przywr√≥cony z kopii zapasowej")

if __name__ == "__main__":
    main() 